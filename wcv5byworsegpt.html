<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebContainer File Runner (NPM + Bundling)</title>
<style>
body { font-family: sans-serif; background: #f9fafb; margin: 0; padding: 2rem; }
.container { max-width: 820px; margin: auto; background: white; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
h1 { font-size: 1.5rem; margin-bottom: 1rem; }
p { font-size: 0.9rem; color: #555; }
button { cursor: pointer; margin-right: 0.5rem; }
.btn { padding: 0.5rem 1rem; border-radius: 0.5rem; border: 1px solid #ccc; background: #f3f4f6; }
.btn-primary { background: #2563eb; color: white; border: none; }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.output { background: black; color: #22c55e; font-family: monospace; padding: 1rem; border-radius: 0.5rem; height: 18rem; overflow: auto; white-space: pre-wrap; }
.status { font-size: 0.75rem; color: #666; margin: 0.5rem 0; }
.error { font-size: 0.9rem; color: red; margin: 0.5rem 0; }
.small { font-size: 0.85rem; color: #666 }
.controls { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap }
#dropZone { border: 2px dashed #ccc; border-radius: 1rem; padding: 2rem; text-align: center; margin-bottom: 1rem; cursor: pointer; background: #f9fafb; }
#dropZone.highlight { background: #e0f2fe; }
</style>
</head>
<body>
  <script>
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/wcptvs/service-worker.js')
                        .then(registration => {
                            console.log('Service Worker registered with scope:', registration.scope);
                        })
                        .catch(error => {
                            console.error('Service Worker registration failed:', error);
                        });
                });
            }
        </script>
<div class="container">
  <h1>WebContainer File Runner (NPM + Bundling)</h1>
  <p class="small">Upload JS/TS projects or drag-and-drop files/folders. Dependencies are installed and bundled automatically.</p>

  <div id="dropZone">Drag & drop files or folders here</div>

  <div class="controls">
    <label>Regular files:</label>
    <input id="fileInputFiles" type="file" multiple>
    <label>Folders:</label>
    <input id="fileInputDirs" type="file" webkitdirectory directory multiple>
    <button id="runBtn" class="btn btn-primary">Run project</button>
    <button id="clearBtn" class="btn" style="margin-left:auto;">Clear output</button>
  </div>

  <div class="status" id="status">Status: Idle</div>
  <div class="error" id="errorMsg"></div>
  <div class="output" id="output">(terminal output will appear here)</div>
</div>

<script>
let webcontainer = null;
let isBooted = false;

const outputEl = document.getElementById("output");
const statusEl = document.getElementById("status");
const errorEl = document.getElementById("errorMsg");
const dropZone = document.getElementById("dropZone");
const fileInputFiles = document.getElementById("fileInputFiles");
const fileInputDirs = document.getElementById("fileInputDirs");

function appendOutput(text) {
  outputEl.textContent += text;
  outputEl.scrollTop = outputEl.scrollHeight;
}

async function bootWebContainer() {
  if (isBooted) return webcontainer;
  appendOutput("Booting WebContainer...\n");
  const { WebContainer } = await import("https://unpkg.com/@webcontainer/api@1.1.0/dist/index.js");
  const wc = await WebContainer.boot({});
  webcontainer = wc;
  isBooted = true;
  statusEl.textContent = "Status: WebContainer ready";
  appendOutput("WebContainer booted.\n");
  return wc;
}

async function installDependencies(wc) {
  appendOutput("Installing npm dependencies...\n");
  const proc = await wc.spawn("npm", ["install"]);
  proc.output.pipeTo(new WritableStream({ write(chunk){ appendOutput(new TextDecoder().decode(chunk)); } }));
  const exitCode = await proc.exit;
  appendOutput("npm install exited with code " + exitCode + "\n");
  return exitCode;
}

async function bundleProject(wc, entry) {
  appendOutput("Bundling project with esbuild...\n");
  const outFile = "out.js";
  const proc = await wc.spawn("npx", [
    "esbuild",
    entry,
    "--bundle",
    `--outfile=${outFile}`,
    "--platform=node",
    "--format=cjs",
    "--sourcemap"
  ]);
  proc.output.pipeTo(new WritableStream({ write(chunk){ appendOutput(new TextDecoder().decode(chunk)); } }));
  const exitCode = await proc.exit;
  appendOutput("esbuild exited with code " + exitCode + "\n");
  return exitCode;
}

async function runProject(files) {
  const wc = await bootWebContainer();

  for (const fileObj of files) {
    const filePath = fileObj.path;
    const dir = filePath.substring(0, filePath.lastIndexOf("/"));
    if (dir) await wc.fs.mkdir(dir, { recursive: true });
    const content = await fileObj.file.text();
    await wc.fs.writeFile(filePath, content);
    appendOutput("Wrote: " + filePath + "\n");
  }

  // Determine entry point
  let entry = null;
  const pkgFile = files.find(f => f.file.name === "package.json");
  if (pkgFile) {
    const code = await installDependencies(wc);
    if (code !== 0) return appendOutput("npm install failed, aborting.\n");
    try {
      const pkg = JSON.parse(await pkgFile.file.text());
      if (pkg.main) entry = pkg.main.startsWith("/") ? pkg.main : "/" + pkg.main;
    } catch { appendOutput("Failed to parse package.json, ignoring main field.\n"); }
  }

  if (!entry) {
    const jsTsFiles = files.map(f => "/" + (f.file.webkitRelativePath || f.file.name))
                           .filter(p => p.endsWith(".js") || p.endsWith(".ts"))
                           .sort();
    if (jsTsFiles.length > 0) entry = jsTsFiles[0];
  }

  if (!entry) return appendOutput("No entry point found, aborting.\n");
  appendOutput("Detected entry point: " + entry + "\n");

  const bundleCode = await bundleProject(wc, entry);
  if (bundleCode !== 0) return appendOutput("Bundling failed, aborting.\n");

  appendOutput("Running bundled out.js...\n");
  const runProc = await wc.spawn("node", ["out.js"]);
  runProc.output.pipeTo(new WritableStream({ write(chunk){ appendOutput(new TextDecoder().decode(chunk)); } }));
  const exitCode = await runProc.exit;
  appendOutput("Process exited with code " + exitCode + "\n");
}

// --- UI HANDLERS ---
async function gatherFiles() {
  const filesArray = [
    ...Array.from(fileInputFiles.files),
    ...Array.from(fileInputDirs.files)
  ];
  return filesArray.map(f => ({ file: f, path: "/" + (f.webkitRelativePath || f.name) }));
}

document.getElementById("runBtn").onclick = async () => {
  const files = await gatherFiles();
  if (!files.length) return appendOutput("Please select files or folders.\n");
  try { await runProject(files); } catch(err) { appendOutput("Error: " + err.message + "\n"); }
};

document.getElementById("clearBtn").onclick = () => {
  outputEl.textContent = "";
  errorEl.textContent = "";
};

// --- DRAG AND DROP ---
dropZone.addEventListener("dragover", e => { e.preventDefault(); dropZone.classList.add("highlight"); });
dropZone.addEventListener("dragleave", e => { e.preventDefault(); dropZone.classList.remove("highlight"); });
dropZone.addEventListener("drop", async e => {
  e.preventDefault(); dropZone.classList.remove("highlight");
  const items = e.dataTransfer.items;
  if (!items) return;

  const filesData = [];
  const traverse = entry => new Promise(resolve => {
    if (entry.isFile) entry.file(f => { filesData.push({ file: f, path: "/" + f.webkitRelativePath || f.name }); resolve(); });
    else if (entry.isDirectory) {
      const reader = entry.createReader();
      reader.readEntries(async entries => { for (const e of entries) await traverse(e); resolve(); });
    }
  });

  for (const item of items) {
    const entry = item.webkitGetAsEntry?.();
    if (entry) await traverse(entry);
  }

  if (!filesData.length) return appendOutput("No files detected in drop.\n");
  await runProject(filesData);
});
</script>
</body>
</html>
