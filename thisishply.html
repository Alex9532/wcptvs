<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebContainer File Runner (Interactive) — Fixed</title>
  <style>
    body { font-family: monospace; background: #111; color: #eee; margin: 0; padding: 1rem; }
    .container { max-width: 900px; margin: auto; background: #1e1e1e; padding: 1rem; border-radius: 0.5rem; }
    h1 { font-size: 1.2rem; margin-bottom: 1rem; color: #90caf9; }
    .controls { margin-bottom: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; }
    .btn { padding: 0.4rem 0.8rem; background: #333; border: 1px solid #555; border-radius: 0.3rem; cursor: pointer; color: #eee; }
    .btn-primary { background: #1976d2; border-color: #1976d2; color: white; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    #dropZone { border: 2px dashed #444; border-radius: 0.5rem; padding: 1rem; text-align: center; margin-bottom: 1rem; color: #aaa; }
    #dropZone.highlight { background: #222; border-color: #90caf9; color: #90caf9; }
    .output { background: #000; color: #eee; font-family: monospace; padding: 1rem; border-radius: 0.3rem; height: 400px; overflow-y: auto; white-space: pre-wrap; }
    .terminal { display: flex; margin-top: 0.5rem; }
    #cmdInput { flex: 1; padding: 0.4rem; background: #111; color: #eee; border: 1px solid #444; border-radius: 0.3rem; font-family: monospace; }
    .muted { color: #9aa3ad; font-size: 0.9rem; }
  </style>
</head>
<body>
  <div class="container">
    <h1>WebContainer File Runner (Interactive) — Fixed</h1>

    <div id="dropZone">Drag & drop files or folders here</div>

    <div class="controls">
      <label>Files: <input id="fileInputFiles" type="file" multiple></label>
      <label>Folders: <input id="fileInputDirs" type="file" webkitdirectory directory multiple></label>
      <button id="runBtn" class="btn btn-primary">Run project</button>
      <button id="clearBtn" class="btn">Clear output</button>
      <label class="muted" style="margin-left:8px;"><input id="useEsbuild" type="checkbox" checked> Use esbuild</label>
    </div>

    <div id="output" class="output">(terminal output will appear here)</div>

    <div class="terminal">
      <input id="cmdInput" type="text" placeholder="Type commands here (press Enter to send). Arrow ↑/↓ for history." autocomplete="off"/>
    </div>
  </div>

<script type="module">
import { WebContainer } from "https://unpkg.com/@webcontainer/api@1.1.7/dist/index.js";

let webcontainer = null;
let isBooted = false;
let currentStdinWriter = null;
let currentProc = null;
let commandHistory = [];
let historyIndex = 0;

const outputEl = document.getElementById("output");
const cmdInput = document.getElementById("cmdInput");
const dropZone = document.getElementById("dropZone");
const fileInputFiles = document.getElementById("fileInputFiles");
const fileInputDirs = document.getElementById("fileInputDirs");
const runBtn = document.getElementById("runBtn");
const clearBtn = document.getElementById("clearBtn");
const useEsbuild = document.getElementById("useEsbuild");

// --- simple ANSI -> HTML mapping (keeps output readable) ---
function escapeHtml(s){ return s.replace(/[&<>]/g, ch => ch === '&' ? '&amp;' : ch === '<' ? '&lt;' : '&gt;'); }
function ansiToHtml(s){
  if(!s) return '';
  s = escapeHtml(s);
  s = s.replace(/\u001b\[0m/g, '</span>');
  s = s.replace(/\u001b\[1m/g, '<span style="font-weight:bold">');
  s = s.replace(/\u001b\[31m/g, '<span style="color:#f44336">');
  s = s.replace(/\u001b\[32m/g, '<span style="color:#4caf50">');
  s = s.replace(/\u001b\[33m/g, '<span style="color:#ffeb3b">');
  s = s.replace(/\u001b\[34m/g, '<span style="color:#2196f3">');
  s = s.replace(/\u001b\[35m/g, '<span style="color:#e91e63">');
  s = s.replace(/\u001b\[36m/g, '<span style="color:#00bcd4">');
  // remove other CSI sequences to avoid artifacts
  s = s.replace(/\u001b\[[\d;]*[A-Za-z]/g, '');
  return s;
}

function appendOutput(text){
  const html = ansiToHtml(text);
  const node = document.createElement('div');
  node.innerHTML = html;
  outputEl.appendChild(node);
  node.scrollIntoView({ block: "end" });
}

/* --- safe streamToOutput: guards against undefined streams/getReader --- */
async function streamToOutput(stream){
  if (!stream) return;
  // ensure it's a ReadableStream with getReader
  if (typeof stream.getReader !== 'function') return;
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  while (true) {
    let result;
    try {
      result = await reader.read();
    } catch (err) {
      appendOutput(`[stream error] ${err?.message || err}\n`);
      break;
    }
    const { value, done } = result;
    if (done) break;
    if (!value) continue;
    let chunk;
    if (value instanceof Uint8Array) chunk = decoder.decode(value);
    else if (value?.buffer instanceof ArrayBuffer) chunk = decoder.decode(new Uint8Array(value.buffer));
    else chunk = String(value);
    appendOutput(chunk);
  }
}

/* --- boot container once --- */
async function bootWebContainer(){
  if (isBooted && webcontainer) return webcontainer;
  appendOutput('Booting WebContainer...\n');
  webcontainer = await WebContainer.boot();
  isBooted = true;
  appendOutput('WebContainer ready.\n');
  return webcontainer;
}

/* --- write files into container safely, one-by-one --- */
async function writeFilesToContainer(files){
  const wc = await bootWebContainer();
  for(const f of files){
    // f may be a File from input or drag/drop
    const path = (f.path) ? f.path : ('/' + (f.webkitRelativePath || f.name));
    const dir = path.substring(0, path.lastIndexOf('/')) || '/';
    try {
      if (dir) await wc.fs.mkdir(dir, { recursive: true });
      // write as Uint8Array to avoid encoding surprises
      const ab = await (f.file ? f.file.arrayBuffer() : f.arrayBuffer());
      const u8 = new Uint8Array(ab);
      await wc.fs.writeFile(path, u8);
      appendOutput(`Wrote: ${path}\n`);
    } catch (err) {
      appendOutput(`Write error (${path}): ${err?.message || err}\n`);
    }
  }
}

/* --- spawn helper that requests pipes and sets currentStdinWriter safely --- */
function safeSpawn(wc, cmd, args = []) {
  return wc.spawn(cmd, args, { stdin: 'pipe', stdout: 'pipe', stderr: 'pipe' });
}

/* --- install dependencies --- */
async function installDependencies(wc){
  appendOutput('Installing npm dependencies...\n');
  const proc = await safeSpawn(wc, 'npm', ['install']);
  if (proc.stdin) currentStdinWriter = proc.stdin.getWriter();
  streamToOutput(proc.output);
  streamToOutput(proc.stderr);
  const exit = await proc.exit;
  appendOutput(`npm install exited with code ${exit}\n`);
  currentStdinWriter = null;
  return exit;
}

/* --- run esbuild (optional) --- */
async function bundleProject(wc, entry){
  appendOutput(`Bundling with esbuild: ${entry}\n`);
  const proc = await safeSpawn(wc, 'npx', ['esbuild', entry, '--bundle', '--outfile=out.js', '--platform=node', '--format=cjs', '--sourcemap']);
  if (proc.stdin) currentStdinWriter = proc.stdin.getWriter();
  streamToOutput(proc.output);
  streamToOutput(proc.stderr);
  const exit = await proc.exit;
  appendOutput(`esbuild exited with code ${exit}\n`);
  currentStdinWriter = null;
  return exit;
}

/* --- run project: write files -> npm install -> optional esbuild -> npm start --- */
async function runProject(files){
  const wc = await bootWebContainer();

  // write uploaded files (files may be File[] from inputs or object {path,file} from drop)
  await writeFilesToContainer(files);

  // detect package.json in provided files
  const pkgFileEntry = files.find(f => {
    const p = f.path ? f.path : ('/' + (f.webkitRelativePath || f.name));
    return p.endsWith('/package.json') || p === '/package.json';
  });

  let pkg = null;
  if (pkgFileEntry) {
    try {
      // read from container FS to be safe
      const pkgPath = pkgFileEntry.path ? pkgFileEntry.path : '/' + (pkgFileEntry.webkitRelativePath || pkgFileEntry.name);
      const raw = await wc.fs.readFile(pkgPath, { encoding: 'utf-8' });
      pkg = JSON.parse(raw);
    } catch (err) {
      appendOutput('Failed to parse package.json from container: ' + (err?.message || err) + '\n');
    }
  }

  // npm install
  const installExit = await installDependencies(wc);
  if (installExit !== 0) {
    appendOutput('npm install failed (exit ' + installExit + ')\n');
    return;
  }

  // optional bundling
  if (useEsbuild.checked) {
    // pick entry: pkg.main or first .js/.ts in uploaded files
    let entry = pkg && pkg.main ? (pkg.main.startsWith('/') ? pkg.main : ('/' + pkg.main)) : null;
    if (!entry) {
      const jsTs = files.map(f => f.path ? f.path : ('/' + (f.webkitRelativePath || f.name))).filter(p => p.endsWith('.js') || p.endsWith('.ts'));
      entry = jsTs.length ? jsTs[0] : '/index.js';
    }
    const bundleExit = await bundleProject(wc, entry);
    if (bundleExit !== 0) {
      appendOutput('esbuild failed (exit ' + bundleExit + ')\n');
      return;
    }
    // after bundling, user likely expects npm start to run the bundle (depends on their package.json)
  }

  // npm start
  appendOutput('Starting project with `npm start`...\n');
  const startProc = await safeSpawn(wc, 'npm', ['start']);
  currentProc = startProc;
  if (startProc.stdin) currentStdinWriter = startProc.stdin.getWriter();
  streamToOutput(startProc.output);
  streamToOutput(startProc.stderr);
  startProc.exit.then(code => {
    appendOutput(`npm start exited with code ${code}\n`);
    currentStdinWriter = null;
    currentProc = null;
  });
}

/* --- helper: convert input FileList or drag-drop entries into consistent list --- */
function filesFromInputs() {
  const out = [];
  for (const f of fileInputFiles.files) out.push({ path: '/' + (f.webkitRelativePath || f.name), file: f });
  for (const f of fileInputDirs.files) out.push({ path: '/' + (f.webkitRelativePath || f.name), file: f });
  return out;
}

/* --- run btn / clear btn handlers --- */
runBtn.addEventListener('click', async () => {
  const inputs = filesFromInputs();
  if (!inputs.length) {
    appendOutput('No files selected. Drag/drop or choose files/folders first.\n');
    return;
  }
  try {
    await runProject(inputs);
  } catch (err) {
    appendOutput('Run error: ' + (err?.message || err) + '\n');
  }
});

clearBtn.addEventListener('click', () => {
  outputEl.innerHTML = '';
});

/* --- drag/drop handling (Chrome-style using webkitGetAsEntry) --- */
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('highlight'); });
dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove('highlight'); });

dropZone.addEventListener('drop', async e => {
  e.preventDefault();
  dropZone.classList.remove('highlight');

  // gather files recursively via DataTransferItem API so folders work
  const items = e.dataTransfer.items;
  if (!items) {
    appendOutput('Drop: no items.\n');
    return;
  }
  const collected = [];
  async function traverse(entry, base) {
    if (entry.isFile) {
      await new Promise(res => entry.file(f => { collected.push({ path: base + f.name, file: f }); res(); }));
    } else if (entry.isDirectory) {
      const reader = entry.createReader();
      const entries = await new Promise(res => reader.readEntries(res));
      for (const en of entries) await traverse(en, base + entry.name + '/');
    }
  }
  for (const it of items) {
    const en = it.webkitGetAsEntry?.();
    if (en) await traverse(en, '/');
  }
  if (!collected.length) {
    appendOutput('No files found in drop.\n');
    return;
  }
  // write and run immediately (user-friendly)
  try {
    await runProject(collected);
  } catch (err) {
    appendOutput('Drop-run error: ' + (err?.message || err) + '\n');
  }
});

/* --- interactive terminal input (stdin piping + history) --- */
cmdInput.addEventListener('keydown', async (e) => {
  // history navigation
  if (e.key === 'ArrowUp') {
    if (commandHistory.length === 0) return;
    historyIndex = Math.max(0, historyIndex - 1);
    cmdInput.value = commandHistory[historyIndex] || '';
    e.preventDefault();
    return;
  }
  if (e.key === 'ArrowDown') {
    if (commandHistory.length === 0) return;
    historyIndex = Math.min(commandHistory.length, historyIndex + 1);
    cmdInput.value = commandHistory[historyIndex] || '';
    e.preventDefault();
    return;
  }

  if (e.key !== 'Enter') return;
  const cmd = cmdInput.value;
  cmdInput.value = '';

  // add to history
  if (cmd.trim()) {
    commandHistory.push(cmd);
    historyIndex = commandHistory.length;
  }

  // show command locally
  appendOutput('$ ' + cmd + '\n');

  // if a process is running and has stdin, send it there
  if (currentStdinWriter) {
    try {
      await currentStdinWriter.write(new TextEncoder().encode(cmd + '\n'));
    } catch (err) {
      appendOutput('Write to stdin failed: ' + (err?.message || err) + '\n');
    }
    return;
  }

  // otherwise spawn the command directly (one-off)
  try {
    const wcInst = await bootWebContainer();
    const parts = cmd.trim().split(/\s+/).filter(Boolean);
    if (parts.length === 0) return;
    const proc = await safeSpawn(wcInst, parts[0], parts.slice(1));
    currentProc = proc;
    if (proc.stdin) currentStdinWriter = proc.stdin.getWriter();
    streamToOutput(proc.output);
    streamToOutput(proc.stderr);
    proc.exit.then(code => {
      appendOutput(`[command exited with ${code}]\n`);
      currentStdinWriter = null;
      currentProc = null;
    });
  } catch (err) {
    appendOutput('Command spawn error: ' + (err?.message || err) + '\n');
  }
});

/* --- warm boot to reduce latency --- */
bootWebContainer().catch(err => appendOutput('Boot failed: ' + (err?.message || err) + '\n'));

</script>
</body>
</html>
