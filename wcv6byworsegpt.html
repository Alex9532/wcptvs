<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebContainer Interactive Runner</title>
<style>
body { font-family: monospace; background: #1e1e1e; color: #ccc; margin: 0; padding: 1rem; }
.container { max-width: 900px; margin: auto; background: #2e2e2e; padding: 1rem; border-radius: 0.75rem; }
h1 { font-size: 1.5rem; margin-bottom: 0.5rem; color: #fff; }
button { cursor: pointer; margin-right: 0.5rem; padding: 0.5rem 1rem; border-radius: 0.3rem; border: none; background: #2563eb; color: #fff; }
#output { background: black; color: lime; padding: 1rem; border-radius: 0.5rem; height: 300px; overflow-y: auto; white-space: pre-wrap; margin-bottom: 0.5rem; }
#cmdInput { width: 100%; padding: 0.5rem; border-radius: 0.3rem; border: none; margin-top: 0.5rem; background:#111; color:#0f0; }
#dropZone { border: 2px dashed #ccc; border-radius: 0.5rem; padding: 2rem; text-align: center; margin-bottom: 0.5rem; cursor: pointer; background: #333; color:#ccc; }
#dropZone.highlight { background: #444; }
.status { font-size:0.85rem; margin-bottom:0.5rem; color:#aaa; }
</style>
</head>
<body>
<div class="container">
  <h1>WebContainer Interactive Runner</h1>
  <p class="status" id="status">Status: Idle</p>
  <div id="dropZone">Drag & drop files or folders here</div>
  <div id="output">(terminal output will appear here)</div>
  <input id="cmdInput" placeholder="Type a command and press Enter">
  <div class="controls" style="margin-top:0.5rem;">
    <input id="fileInputFiles" type="file" multiple>
    <input id="fileInputDirs" type="file" webkitdirectory directory multiple>
    <button id="runBtn">Run project</button>
    <button id="clearBtn">Clear output</button>
  </div>
</div>

<script>
let webcontainer = null;
let isBooted = false;
const outputEl = document.getElementById("output");
const statusEl = document.getElementById("status");
const dropZone = document.getElementById("dropZone");
const fileInputFiles = document.getElementById("fileInputFiles");
const fileInputDirs = document.getElementById("fileInputDirs");
const cmdInput = document.getElementById("cmdInput");
let currentStdinWriter = null;

// --- ANSI parser ---
function ansiToHtml(text) {
  const ANSI_COLORS = {
    "30": "black","31":"red","32":"green","33":"yellow","34":"blue",
    "35":"magenta","36":"cyan","37":"white","90":"gray"
  };
  return text.replace(/\x1b\[(\d+)m/g, (_, code)=>`<span style="color:${ANSI_COLORS[code]||'inherit'}">`).replace(/\x1b\[0m/g,"</span>");
}

// --- append colored output ---
function appendOutput(text, type="stdout") {
  const html = ansiToHtml(text);
  const div = document.createElement("div");
  div.innerHTML = html;
  outputEl.appendChild(div);
  outputEl.scrollTop = outputEl.scrollHeight;
}

// --- safe stream to output ---
async function streamToOutput(readable, type="stdout") {
  if (!readable) return;
  const reader = readable.getReader();
  const decoder = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    if (!value) continue;
    let chunk;
    if (value instanceof Uint8Array) chunk = decoder.decode(value);
    else if (value.buffer instanceof ArrayBuffer) chunk = decoder.decode(new Uint8Array(value.buffer));
    else chunk = String(value);
    appendOutput(chunk, type);
  }
}

// --- boot container ---
async function bootWebContainer() {
  if(isBooted) return webcontainer;
  appendOutput("Booting WebContainer...");
  const { WebContainer } = await import("https://unpkg.com/@webcontainer/api@1.1.0/dist/index.js");
  webcontainer = await WebContainer.boot({});
  isBooted = true;
  statusEl.textContent = "WebContainer ready";
  appendOutput("WebContainer booted.\n");
  return webcontainer;
}

// --- write files ---
async function writeFiles(files) {
  const wc = await bootWebContainer();
  for(const f of files) {
    const path = "/" + (f.webkitRelativePath||f.name);
    const dir = path.substring(0,path.lastIndexOf("/"));
    if(dir) await wc.fs.mkdir(dir, {recursive:true});
    const content = await f.text();
    await wc.fs.writeFile(path, content);
    appendOutput(`Wrote: ${path}`);
  }
}

// --- install dependencies ---
async function installDependencies(wc) {
  appendOutput("Installing npm dependencies...");
  const proc = await wc.spawn("npm", ["install"], {stdin:"pipe"});
  currentStdinWriter = proc.stdin.getWriter();
  await streamToOutput(proc.output);
  await streamToOutput(proc.stderr,"stderr");
  const code = await proc.exit;
  appendOutput(`npm install exited with code ${code}`);
  currentStdinWriter = null;
  return code;
}

// --- bundle project ---
async function bundleProject(wc, entry) {
  appendOutput("Bundling project with esbuild...");
  const proc = await wc.spawn("npx", ["esbuild", entry, "--bundle", "--outfile=out.js", "--platform=node","--format=cjs","--sourcemap"], {stdin:"pipe"});
  currentStdinWriter = proc.stdin.getWriter();
  await streamToOutput(proc.output);
  await streamToOutput(proc.stderr,"stderr");
  const code = await proc.exit;
  appendOutput(`esbuild exited with code ${code}`);
  currentStdinWriter = null;
  return code;
}

// --- run project ---
async function runProject(files) {
  const wc = await bootWebContainer();
  await writeFiles(files);
  let entry = files.find(f=>f.name==="package.json")?.name || files.find(f=>f.name.endsWith(".js")||f.name.endsWith(".ts"))?.name;
  if(!entry) { appendOutput("No entry point found","stderr"); return; }
  entry = "/" + entry;

  if(files.some(f=>f.name==="package.json")) {
    const code = await installDependencies(wc);
    if(code!==0) return appendOutput("npm install failed","stderr");
  }

  const bundleCode = await bundleProject(wc, entry);
  if(bundleCode!==0) return appendOutput("Bundling failed","stderr");

  appendOutput("Running bundled out.js...");
  const proc = await wc.spawn("node", ["out.js"], {stdin:"pipe"});
  currentStdinWriter = proc.stdin.getWriter();
  await streamToOutput(proc.output,"stdout");
  await streamToOutput(proc.stderr,"stderr");
  await proc.exit;
  currentStdinWriter = null;
  appendOutput("Process exited.\n");
}

// --- gather files ---
function gatherFiles() { return [...Array.from(fileInputFiles.files), ...Array.from(fileInputDirs.files)]; }

// --- UI handlers ---
document.getElementById("runBtn").onclick = async ()=> {
  const files = gatherFiles();
  if(!files.length) return appendOutput("Please select files or folders","stderr");
  try { await runProject(files); } catch(e){ appendOutput("Error: "+e.message,"stderr"); }
};
document.getElementById("clearBtn").onclick = ()=> { outputEl.textContent=""; statusEl.textContent="Idle"; };

// --- drag/drop ---
dropZone.addEventListener("dragover", e=>{e.preventDefault(); dropZone.classList.add("highlight");});
dropZone.addEventListener("dragleave", e=>{e.preventDefault(); dropZone.classList.remove("highlight");});
dropZone.addEventListener("drop", async e=>{
  e.preventDefault(); dropZone.classList.remove("highlight");
  const items = e.dataTransfer.items;
  if(!items) return;
  const files = [];
  for(const item of items) {
    const entry = item.webkitGetAsEntry?.();
    if(!entry) continue;
    const traverse = entry => new Promise(resolve=>{
      if(entry.isFile) entry.file(f=>{files.push(f); resolve();});
      else if(entry.isDirectory){
        const reader = entry.createReader();
        reader.readEntries(async ents=>{for(const e of ents) await traverse(e); resolve();});
      }
    });
    await traverse(entry);
  }
  if(!files.length) return appendOutput("No files detected","stderr");
  await runProject(files);
});

// --- interactive terminal ---
let commandHistory=[],historyIndex=-1;
cmdInput.addEventListener("keydown", async e=>{
  if(e.key==="ArrowUp"){ if(commandHistory.length>0){ historyIndex=Math.max(0,historyIndex-1); cmdInput.value=commandHistory[historyIndex]; } e.preventDefault(); return; }
  if(e.key==="ArrowDown"){ if(commandHistory.length>0){ historyIndex=Math.min(commandHistory.length-1,historyIndex+1); cmdInput.value=commandHistory[historyIndex]||""; } e.preventDefault(); return; }
  if(e.key!=="Enter") return;

  const cmd = cmdInput.value.trim();
  if(!cmd) return;
  appendOutput("> "+cmd);
  commandHistory.push(cmd);
  historyIndex=commandHistory.length;
  cmdInput.value="";
  if(currentStdinWriter){
    await currentStdinWriter.write(new TextEncoder().encode(cmd+"\n"));
  } else {
    try {
      const wc = await bootWebContainer();
      const parts = cmd.split(" ");
      const proc = await wc.spawn(parts[0], parts.slice(1), {stdin:"pipe"});
      currentStdinWriter = proc.stdin.getWriter();
      await streamToOutput(proc.output,"stdout");
      await streamToOutput(proc.stderr,"stderr");
      await proc.exit;
      currentStdinWriter=null;
    } catch(err){ appendOutput("Error: "+err.message,"stderr"); }
  }
});
</script>
</body>
</html>
