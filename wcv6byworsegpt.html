<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebContainer Interactive Runner</title>
<style>
body { font-family: monospace; background: #1e1e1e; color: #ccc; margin: 0; padding: 1rem; }
.container { max-width: 900px; margin: auto; background: #2e2e2e; padding: 1rem; border-radius: 0.75rem; }
h1 { font-size: 1.5rem; margin-bottom: 0.5rem; color: #fff; }
button { cursor: pointer; margin-right: 0.5rem; padding: 0.5rem 1rem; border-radius: 0.3rem; border: none; background: #2563eb; color: #fff; }
#output { background: black; color: lime; padding: 1rem; border-radius: 0.5rem; height: 300px; overflow-y: auto; white-space: pre-wrap; margin-bottom: 0.5rem; }
#cmdInput { width: 100%; padding: 0.5rem; border-radius: 0.3rem; border: none; margin-top: 0.5rem; background:#111; color:#0f0; }
#dropZone { border: 2px dashed #ccc; border-radius: 0.5rem; padding: 2rem; text-align: center; margin-bottom: 0.5rem; cursor: pointer; background: #333; color:#ccc; }
#dropZone.highlight { background: #444; }
#progressContainer { width:100%; background:#555; border-radius:0.5rem; margin-bottom:0.5rem; height:1rem; }
#progressBar { width:0%; height:100%; background:#2563eb; border-radius:0.5rem; transition: width 0.1s; }
.status { font-size:0.85rem; margin-bottom:0.5rem; color:#aaa; }
</style>
</head>
<body>
<div class="container">
  <h1>WebContainer Interactive Runner</h1>
  <p class="status" id="status">Status: Idle</p>
  <div id="dropZone">Drag & drop files or folders here</div>
  <div id="progressContainer"><div id="progressBar"></div></div>
  <div id="output">(terminal output will appear here)</div>
  <input id="cmdInput" placeholder="Type a command and press Enter">
  <div class="controls" style="margin-top:0.5rem;">
    <input id="fileInputFiles" type="file" multiple>
    <input id="fileInputDirs" type="file" webkitdirectory directory multiple>
    <button id="runBtn">Run project</button>
    <button id="clearBtn">Clear output</button>
  </div>
</div>

<script>
let webcontainer = null;
let isBooted = false;
const outputEl = document.getElementById("output");
const statusEl = document.getElementById("status");
const dropZone = document.getElementById("dropZone");
const progressBar = document.getElementById("progressBar");
const fileInputFiles = document.getElementById("fileInputFiles");
const fileInputDirs = document.getElementById("fileInputDirs");
const cmdInput = document.getElementById("cmdInput");

// --- append colored output ---
function appendOutput(text, type="stdout") {
  const span = document.createElement("span");
  span.textContent = text + "\n";
  span.style.color = type==="stderr"?"red":"lime";
  outputEl.appendChild(span);
  outputEl.scrollTop = outputEl.scrollHeight;
}

// --- safe stream to output ---
async function streamToOutput(readable, type="stdout") {
  if (!readable) return;
  const reader = readable.getReader();
  const decoder = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    if (!value) continue;
    let chunk;
    if (value instanceof Uint8Array) {
      chunk = decoder.decode(value);
    } else if (value.buffer instanceof ArrayBuffer) {
      chunk = decoder.decode(new Uint8Array(value.buffer));
    } else {
      chunk = String(value);
    }
    appendOutput(chunk, type);
  }
}

// --- boot container ---
async function bootWebContainer() {
  if(isBooted) return webcontainer;
  appendOutput("Booting WebContainer...");
  const { WebContainer } = await import("https://unpkg.com/@webcontainer/api@1.1.0/dist/index.js");
  webcontainer = await WebContainer.boot({});
  isBooted = true;
  statusEl.textContent = "WebContainer ready";
  appendOutput("WebContainer booted.\n");
  return webcontainer;
}

// --- write files ---
async function writeFiles(files) {
  const wc = await bootWebContainer();
  const totalFiles = files.length;
  let written = 0;
  for(const f of files) {
    const path = "/" + (f.webkitRelativePath||f.name);
    const dir = path.substring(0,path.lastIndexOf("/"));
    if(dir) await wc.fs.mkdir(dir, {recursive:true});
    const content = await f.text();
    await wc.fs.writeFile(path, content);
    written++;
    progressBar.style.width = Math.floor((written/totalFiles)*100)+"%";
    statusEl.textContent = `Writing files: ${written}/${totalFiles}`;
    appendOutput(`Wrote: ${path}`);
  }
  statusEl.textContent = "All files written.";
}

// --- install dependencies ---
async function installDependencies(wc) {
  appendOutput("Installing npm dependencies...");
  const proc = await wc.spawn("npm", ["install"]);
  await streamToOutput(proc.output);
  const code = await proc.exit;
  appendOutput(`npm install exited with code ${code}`);
  return code;
}

// --- bundle project ---
async function bundleProject(wc, entry) {
  appendOutput("Bundling project with esbuild...");
  const outFile = "out.js";
  const proc = await wc.spawn("npx", ["esbuild", entry, "--bundle", `--outfile=${outFile}`, "--platform=node","--format=cjs","--sourcemap"]);
  await streamToOutput(proc.output);
  const code = await proc.exit;
  appendOutput(`esbuild exited with code ${code}`);
  return code;
}

// --- run project ---
async function runProject(files) {
  const wc = await bootWebContainer();
  await writeFiles(files);
  
  let entry = files.find(f=>f.name==="package.json")?.name || files.find(f=>f.name.endsWith(".js")||f.name.endsWith(".ts"))?.name;
  if(!entry) { appendOutput("No entry point found","stderr"); return; }

  entry = "/" + entry;

  if(files.some(f=>f.name==="package.json")) {
    const code = await installDependencies(wc);
    if(code!==0) return appendOutput("npm install failed","stderr");
  }

  const bundleCode = await bundleProject(wc, entry);
  if(bundleCode!==0) return appendOutput("Bundling failed","stderr");

  appendOutput("Running bundled out.js...");
  const proc = await wc.spawn("node", ["out.js"]);
  await streamToOutput(proc.output,"stdout");
  await streamToOutput(proc.stderr,"stderr");
  appendOutput("Process exited.\n");
}

// --- gather files ---
function gatherFiles() {
  return [...Array.from(fileInputFiles.files), ...Array.from(fileInputDirs.files)];
}

// --- UI handlers ---
document.getElementById("runBtn").onclick = async ()=> {
  const files = gatherFiles();
  if(!files.length) return appendOutput("Please select files or folders","stderr");
  try { await runProject(files); } catch(e){ appendOutput("Error: "+e.message,"stderr"); }
};
document.getElementById("clearBtn").onclick = ()=> { outputEl.textContent=""; progressBar.style.width="0%"; statusEl.textContent="Idle"; };

// --- drag/drop ---
dropZone.addEventListener("dragover", e=>{e.preventDefault(); dropZone.classList.add("highlight");});
dropZone.addEventListener("dragleave", e=>{e.preventDefault(); dropZone.classList.remove("highlight");});
dropZone.addEventListener("drop", async e=>{
  e.preventDefault(); dropZone.classList.remove("highlight");
  const items = e.dataTransfer.items;
  if(!items) return;
  const files = [];
  for(const item of items) {
    const entry = item.webkitGetAsEntry?.();
    if(!entry) continue;
    const traverse = entry => new Promise(resolve=>{
      if(entry.isFile) entry.file(f=>{files.push(f); resolve();});
      else if(entry.isDirectory){
        const reader = entry.createReader();
        reader.readEntries(async ents=>{for(const e of ents) await traverse(e); resolve();});
      }
    });
    await traverse(entry);
  }
  if(!files.length) return appendOutput("No files detected","stderr");
  await runProject(files);
});

// --- interactive terminal with command history ---
let commandHistory = [];
let historyIndex = -1;
cmdInput.addEventListener("keydown", async e=>{
  if(e.key==="ArrowUp") { if(commandHistory.length>0){ historyIndex=Math.max(0,historyIndex-1); cmdInput.value=commandHistory[historyIndex]; } e.preventDefault(); return; }
  if(e.key==="ArrowDown") { if(commandHistory.length>0){ historyIndex=Math.min(commandHistory.length-1,historyIndex+1); cmdInput.value=commandHistory[historyIndex]||""; } e.preventDefault(); return; }
  if(e.key!=="Enter") return;

  const cmd = cmdInput.value.trim();
  if(!cmd) return;
  cmdInput.value="";
  appendOutput("$ "+cmd,"stdout");

  commandHistory.push(cmd);
  historyIndex = commandHistory.length;

  try{
    const wc = await bootWebContainer();
    const parts = cmd.split(" ");
    const proc = await wc.spawn(parts[0], parts.slice(1));
    await streamToOutput(proc.output,"stdout");
    await streamToOutput(proc.stderr,"stderr");
    await proc.exit;
  } catch(err){ appendOutput("Error: "+err.message,"stderr"); }
});
</script>
</body>
</html>
