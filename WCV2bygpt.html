<!--
WebContainer File Runner (Vanilla JS + HTML + CSS) â€” TypeScript-safe version

Changes in this revision:
- Detects TypeScript (.ts, .tsx) and JSX (.jsx) files and automatically transpiles them to plain JavaScript using Sucrase (loaded at runtime) before executing in the WebContainer. This avoids the "Unexpected token" errors when a TypeScript/TSX file is uploaded and the environment doesn't support TypeScript.
- Keeps existing JavaScript behavior unchanged.
- Adds an extra sample test case `sample.ts` to validate TypeScript transpilation.
- Improves error messages and logs so you can see if a file was transpiled or rejected.

Notes / next steps for you:
- If you want full multi-file TypeScript project support (e.g., compiling many TS/TSX files with imports and bundling), tell me whether you'd like an in-browser bundler (esbuild-wasm) or to run `npm` + builder inside the WebContainer. I'll implement whichever you prefer.
- Question: When a TypeScript/TSX project contains React imports, do you want the app to automatically install `react`/`react-dom` inside the container (network + npm in WebContainer), or should we limit transpilation to single-file TypeScript without external deps? Please tell me the expected behavior.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebContainer File Runner (TS-aware)</title>
  <style>
    body { font-family: sans-serif; background: #f9fafb; margin: 0; padding: 2rem; }
    .container { max-width: 820px; margin: auto; background: white; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    h1 { font-size: 1.5rem; margin-bottom: 1rem; }
    p { font-size: 0.9rem; color: #555; }
    button { cursor: pointer; margin-right: 0.5rem; }
    .btn { padding: 0.5rem 1rem; border-radius: 0.5rem; border: 1px solid #ccc; background: #f3f4f6; }
    .btn-primary { background: #2563eb; color: white; border: none; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .output { background: black; color: #22c55e; font-family: monospace; padding: 1rem; border-radius: 0.5rem; height: 18rem; overflow: auto; white-space: pre-wrap; }
    .status { font-size: 0.75rem; color: #666; margin: 0.5rem 0; }
    .error { font-size: 0.9rem; color: red; margin: 0.5rem 0; }
    .small { font-size: 0.85rem; color: #666 }
    .controls { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap }
  </style>
</head>
<body>
  <div class="container">
    <h1>WebContainer File Runner (TS-aware)</h1>
    <p class="small">Upload a JavaScript (<code>.js</code>) file, TypeScript (<code>.ts</code>), or JSX/TSX (<code>.jsx</code>/<code>.tsx</code>) file and execute it inside a WebContainer. TypeScript/TSX/JSX files are automatically transpiled in the browser before running.</p>

    <div style="margin-bottom: 1rem;" class="controls">
      <input id="fileInput" type="file" accept=".js,.ts,.tsx,.jsx">
      <button id="runBtn" class="btn btn-primary">Run uploaded file</button>
      <button id="helloBtn" class="btn">Run sample: hello.js</button>
      <button id="errorBtn" class="btn">Run sample: error.js</button>
      <button id="asyncBtn" class="btn">Run sample: async.js</button>
      <button id="sampleTsBtn" class="btn">Run sample: sample.ts</button>
      <button id="clearBtn" class="btn" style="margin-left:auto;">Clear output</button>
    </div>

    <div class="status" id="status">Status: Idle</div>
    <div class="error" id="errorMsg"></div>
    <div class="output" id="output">(terminal output will appear here)</div>

    <div class="status">
      <strong>Security notice:</strong> this runs inside an in-browser container provided by WebContainer. Be careful running untrusted code.
    </div>
  </div>

  <script>
    // State
    let webcontainer = null;
    let isBooted = false;
    let running = false;

    // DOM refs
    const outputEl = document.getElementById("output");
    const statusEl = document.getElementById("status");
    const errorEl = document.getElementById("errorMsg");
    const fileInput = document.getElementById("fileInput");

    // Sample scripts (tests)
    const samples = {
      "hello.js": `console.log("Hello from WebContainer!");`,
      "error.js": `console.log('About to throw'); throw new Error('This is a test error from error.js');`,
      "async.js": `setTimeout(() => console.log('Delayed output after 1s'), 1000);`,
      // TypeScript sample (no external deps) to validate transpilation
      "sample.ts": `const add = (a: number, b: number): number => a + b; console.log('2 + 3 =', add(2, 3));`
    };

    function appendOutput(text) {
      outputEl.textContent += text;
      outputEl.scrollTop = outputEl.scrollHeight;
    }

    async function bootWebContainer() {
      if (isBooted) return webcontainer;
      appendOutput("Booting WebContainer...");
      try {
        const url = "https://unpkg.com/@webcontainer/api@1.1.0/dist/index.js";
        // Prevent bundlers from rewriting the dynamic import URL at build time.
        // @vite-ignore
        const { WebContainer } = await import(/* webpackIgnore: true */ url);
        const wc = await WebContainer.boot({});
        webcontainer = wc;
        isBooted = true;
        statusEl.textContent = "Status: WebContainer ready";
        appendOutput("WebContainer booted.");
        return wc;
      } catch (err) {
        const msg = err && err.message ? err.message : String(err);
        errorEl.textContent = "Last error: " + msg;
        appendOutput("Failed to boot WebContainer: " + msg + "");
        throw err;
      }
    }

    async function writeSkeletonProject(wc) {
      // Minimal package.json so node won't complain
      await wc.fs.writeFile("/package.json", JSON.stringify({ name: "webcontainer-runner", version: "1.0.0" }, null, 2));
    }

    // Load Sucrase (UMD build) if we need to transpile TypeScript/JSX.
    async function ensureSucraseLoaded() {
      if (window.Sucrase) return;
      return new Promise((resolve, reject) => {
        const url = "https://unpkg.com/sucrase@3.33.0/dist/sucrase.min.js";
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.onload = () => resolve();
        script.onerror = (e) => reject(new Error('Failed to load Sucrase from ' + url));
        document.head.appendChild(script);
      });
    }

    // Transform TypeScript/TSX/JSX to plain JavaScript using Sucrase.
    async function transformIfNeeded(filename, content) {
      const lower = filename.toLowerCase();
      if (lower.endsWith('.ts') || lower.endsWith('.tsx')) {
        appendOutput(`Transpiling ${filename} -> JS via Sucrase...`);
        try {
          await ensureSucraseLoaded();
          // For .tsx we need both typescript and jsx transforms
          const transforms = lower.endsWith('.tsx') ? ['typescript', 'jsx'] : ['typescript'];
          const result = window.Sucrase.transform(content, { transforms });
          const outName = filename.replace(/\.tsx?$/i, '.js');
          return { filename: outName, content: result.code };
        } catch (err) {
          appendOutput('Failed to transpile TypeScript: ' + (err && err.message ? err.message : String(err)) + '');
          throw err;
        }
      }

      if (lower.endsWith('.jsx')) {
        appendOutput(`Transpiling ${filename} (JSX -> JS) via Sucrase...`);
        try {
          await ensureSucraseLoaded();
          const result = window.Sucrase.transform(content, { transforms: ['jsx'] });
          const outName = filename.replace(/\.jsx$/i, '.js');
          return { filename: outName, content: result.code };
        } catch (err) {
          appendOutput('Failed to transpile JSX: ' + (err && err.message ? err.message : String(err)) + '');
          throw err;
        }
      }

      // no transform needed
      return { filename, content };
    }

    async function runFileInWebContainer(filename, content) {
      errorEl.textContent = "";

      // If this looks like TypeScript/JSX, try to transpile client-side before writing
      try {
        const transformed = await transformIfNeeded(filename, content);
        filename = transformed.filename;
        content = transformed.content;
      } catch (err) {
        appendOutput('Aborting run due to transpile failure.');
        return;
      }

      const wc = await bootWebContainer();
      try {
        await writeSkeletonProject(wc);
        const path = '/' + filename;
        await wc.fs.writeFile(path, content);
        appendOutput('Wrote file to WebContainer: ' + path + '');
        appendOutput('Starting node ' + filename + '...');
        running = true;

        const proc = await wc.spawn('node', [filename]);
        proc.output.pipeTo(new WritableStream({
          write(chunk) { appendOutput(new TextDecoder().decode(chunk)); }
        }));

        const exitCode = await proc.exit;
        appendOutput('Process exited with code ' + exitCode + '.');
      } catch (err) {
        appendOutput('Error while running file: ' + (err && err.message ? err.message : String(err)) + '.');
        console.error(err);
      } finally {
        running = false;
      }
    }

    // UI wiring
    document.getElementById('runBtn').onclick = async () => {
      if (!fileInput.files.length) {
        appendOutput('Please choose a file first.');
        return;
      }
      const file = fileInput.files[0];
      const text = await file.text();
      await runFileInWebContainer(file.name, text);
    };

    document.getElementById('helloBtn').onclick = () => {
      appendOutput('\n--- Running sample: hello.js --- ');
      runFileInWebContainer('hello.js', samples['hello.js']);
    };

    document.getElementById('errorBtn').onclick = () => {
      appendOutput('\n--- Running sample: error.js --- ');
      runFileInWebContainer('error.js', samples['error.js']);
    };

    document.getElementById('asyncBtn').onclick = () => {
      appendOutput('\n--- Running sample: async.js --- ');
      runFileInWebContainer('async.js', samples['async.js']);
    };

    document.getElementById('sampleTsBtn').onclick = () => {
      appendOutput('\n--- Running sample: sample.ts (TypeScript) --- ');
      runFileInWebContainer('sample.ts', samples['sample.ts']);
    };

    document.getElementById('clearBtn').onclick = () => {
      outputEl.textContent = '';
      errorEl.textContent = '';
    };
  </script>
</body>
</html>
