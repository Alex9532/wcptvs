<!--
WebContainer File Runner (Vanilla JS + HTML + CSS) with NPM + Bundling Support

Fixes:
- Removed any accidental references to https://stackblitz.com/headless (not needed, and causes 404).
- Ensures we only load @webcontainer/api from unpkg CDN.
- Adds logic to detect package.json, run npm install inside the WebContainer, and use esbuild for bundling before execution.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebContainer File Runner (NPM + Bundling)</title>
  <style>
    body { font-family: sans-serif; background: #f9fafb; margin: 0; padding: 2rem; }
    .container { max-width: 820px; margin: auto; background: white; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    h1 { font-size: 1.5rem; margin-bottom: 1rem; }
    p { font-size: 0.9rem; color: #555; }
    button { cursor: pointer; margin-right: 0.5rem; }
    .btn { padding: 0.5rem 1rem; border-radius: 0.5rem; border: 1px solid #ccc; background: #f3f4f6; }
    .btn-primary { background: #2563eb; color: white; border: none; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .output { background: black; color: #22c55e; font-family: monospace; padding: 1rem; border-radius: 0.5rem; height: 18rem; overflow: auto; white-space: pre-wrap; }
    .status { font-size: 0.75rem; color: #666; margin: 0.5rem 0; }
    .error { font-size: 0.9rem; color: red; margin: 0.5rem 0; }
    .small { font-size: 0.85rem; color: #666 }
    .controls { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap }
  </style>
</head>
<body>
  <div class="container">
    <h1>WebContainer File Runner (NPM + Bundling)</h1>
    <p class="small">Upload JavaScript/TypeScript projects. If <code>package.json</code> is included, dependencies are installed inside the WebContainer and the project is bundled with esbuild before execution.</p>

    <div class="controls">
      <input id="fileInput" type="file" accept="*/*" webkitdirectory directory multiple>
      <button id="runBtn" class="btn btn-primary">Run project</button>
      <button id="clearBtn" class="btn" style="margin-left:auto;">Clear output</button>
    </div>

    <div class="status" id="status">Status: Idle</div>
    <div class="error" id="errorMsg"></div>
    <div class="output" id="output">(terminal output will appear here)</div>
  </div>
<script>
let webcontainer = null;
let isBooted = false;

const outputEl = document.getElementById("output");
const statusEl = document.getElementById("status");
const errorEl = document.getElementById("errorMsg");
const fileInput = document.getElementById("fileInput");

function appendOutput(text) {
  outputEl.textContent += text;
  outputEl.scrollTop = outputEl.scrollHeight;
}

async function bootWebContainer() {
  if (isBooted) return webcontainer;
  appendOutput("Booting WebContainer...\n");
  try {
    const url = "https://unpkg.com/@webcontainer/api@1.1.0/dist/index.js";
    // @vite-ignore
    const { WebContainer } = await import(/* webpackIgnore: true */ url);
    const wc = await WebContainer.boot({});
    webcontainer = wc;
    isBooted = true;
    statusEl.textContent = "Status: WebContainer ready";
    appendOutput("WebContainer booted.\n");
    return wc;
  } catch (err) {
    const msg = err?.message ?? String(err);
    errorEl.textContent = "Last error: " + msg;
    appendOutput("Failed to boot WebContainer: " + msg + "\n");
    throw err;
  }
}

async function installDependencies(wc) {
  appendOutput("Installing npm dependencies...\n");
  const installProc = await wc.spawn("npm", ["install"]);
  installProc.output.pipeTo(new WritableStream({
    write(chunk) { appendOutput(new TextDecoder().decode(chunk)); }
  }));
  const exitCode = await installProc.exit;
  appendOutput("npm install exited with code " + exitCode + "\n");
  return exitCode;
}

async function bundleProject(wc, entry) {
  appendOutput("Bundling project with esbuild...\n");
  const outFile = "out.js";
  const bundleProc = await wc.spawn("npx", [
    "esbuild",
    entry,
    "--bundle",
    `--outfile=${outFile}`,
    "--platform=node",
    "--format=cjs",
    "--sourcemap"
  ]);
  bundleProc.output.pipeTo(new WritableStream({
    write(chunk) { appendOutput(new TextDecoder().decode(chunk)); }
  }));
  const exitCode = await bundleProc.exit;
  appendOutput("esbuild exited with code " + exitCode + "\n");
  return exitCode;
}

async function runProject(files) {
  const wc = await bootWebContainer();

  // Stream files directly into WebContainer one by one
  for (const file of files) {
    const filePath = "/" + file.webkitRelativePath;
    const dir = filePath.substring(0, filePath.lastIndexOf("/"));
    if (dir) await wc.fs.mkdir(dir, { recursive: true });

    const content = await file.text(); // only one file in memory at a time
    await wc.fs.writeFile(filePath, content);
    appendOutput("Wrote: " + filePath + "\n");
  }

  // Determine entry point
  let entry = null;

  const pkgFile = files.find(f => f.name === "package.json");
  if (pkgFile) {
    const code = await installDependencies(wc);
    if (code !== 0) {
      appendOutput("npm install failed, aborting.\n");
      return;
    }

    try {
      const pkg = JSON.parse(await pkgFile.text());
      if (pkg.main) entry = pkg.main.startsWith("/") ? pkg.main : "/" + pkg.main;
    } catch {
      appendOutput("Failed to parse package.json, ignoring main field.\n");
    }
  }

  // Recursive search for first .js or .ts file if no entry yet
  if (!entry) {
    const jsTsFiles = Array.from(files)
      .map(f => "/" + f.webkitRelativePath)
      .filter(p => p.endsWith(".js") || p.endsWith(".ts"))
      .sort();
    if (jsTsFiles.length > 0) entry = jsTsFiles[0];
  }

  if (!entry) {
    appendOutput("No entry point found, aborting.\n");
    return;
  }

  appendOutput("Detected entry point: " + entry + "\n");

  // Bundle project
  const bundleCode = await bundleProject(wc, entry);
  if (bundleCode !== 0) {
    appendOutput("Bundling failed, aborting.\n");
    return;
  }

  // Run bundled file with real-time logging
  appendOutput("Running bundled out.js...\n");
  const runProc = await wc.spawn("node", ["out.js"]);
  runProc.output.pipeTo(new WritableStream({
    write(chunk) { appendOutput(new TextDecoder().decode(chunk)); }
  }));
  const exitCode = await runProc.exit;
  appendOutput("Process exited with code " + exitCode + "\n");
};

// --- UI EVENTS ---
document.getElementById("runBtn").onclick = async () => {
  if (!fileInput.files.length) {
    appendOutput("Please choose a project folder.\n");
    return;
  }

  try {
    // Pass FileList directly â†’ files will be streamed in runProject
    await runProject(Array.from(fileInput.files));

  } catch (err) {
    appendOutput("Error: " + err.message + "\n");
  }
};

document.getElementById("clearBtn").onclick = () => {
  outputEl.textContent = "";
  errorEl.textContent = "";
};
</script>
</body>
</html>
